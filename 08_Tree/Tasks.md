## Практикум 8
### Задачи
### Дървета

<b>Задача 1.</b>  
Напишете функция, която по подадено двоично дърво от цели числа намира листото с най-голяма стойност.  

<b>Задача 2.</b>   
Нека е дадено двоично наредено дърво от цели числа и цяло число <b>x</b>. Напишете функция, която добавя дадената стойност на коректно място в дървото.

<b>Задача 3.</b>     
а) Нека е дадено двоично наредено дърво от цели числа и две цели числа, които се съдържат в дървото - x, y. Намере LCA на x и y.
[Линк към задачата](https://www.hackerrank.com/challenges/binary-search-tree-lowest-common-ancestor/problem)  

б) Ами ако дървото не е наредено ?

<b>Задача 4.</b>  
[Линк към задачата](https://www.hackerrank.com/challenges/tree-huffman-decoding/problem)

<b>Задача 5.</b>  
Напишете функция, която проверява дали едно двоично дърво е балансирано по височина.

<b>Задача 6.</b>  
Нека имаме следното представяне на дърво :  

```cpp
struct Node {
  int data;
  std::forward_list<Node*> childs;
};
```
Напишете фунцкия, която намира максималната разклоненост(брой деца) на дърво.

<b>БОНУС</b> : Напишете функция, която приема низ от вида {root childs} и връща указател от тип Node, който представлява корена на дървото, представено чрез низа {root childs}.
Всеки елемент на childs  е или число или дърво.
```
Пример: {1 {1 2 3} 4}
```
