# Практикум 3

## Задачи за опашки
### Опашки

#### Задача 1
Да се напише функция, която получава опашка и връща нова опашка съдържаща елементите на подадената опашка в обратен ред.

#### Задача 2
Да се напише функция, която по подадени две опашки съдържащи сортирани в нарастващ ред цели числа, да връща нова опашка съдържаща елементите от подадените опашки сортирани в нарастващ ред.

#### Задача 3 - [Josephus Problem](https://en.wikipedia.org/wiki/Josephus_problem)
Да се напише функция, която при подадени естествени числа `n` и `k` решава [задачата на Йосив Флавиий](https://bg.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BD%D0%B0_%D0%99%D0%BE%D1%81%D0%B8%D1%84_%D0%A4%D0%BB%D0%B0%D0%B2%D0%B8%D0%B9) за `n` хора наредени в кръг, като всеки `k`-ти отпада, започвайки от броенето от първия. Функцията връща последната останала позиция.

#### Постановка на задачата
Имаме `n` хора номерирани от 1 до n включително, започваме да броим от хора на позиция 1, всеки `k`-ти човек от кръга отпада. Този процес се изпълнява до моментът в който остане един единствен човек от всички `n` първоначални хора.

|  n  |  k  | Последна останала позиция |
| --- | --- | ------------------------- |
| 14  |  2  | 13                        |
| 10  |  3  | 4                         |
| 8   |  2  | 1                         |
| 9   |  3  | 1                         |

**Важно:** Има много по-добри решения на тази задача от това което ще разгледаме.

#### Задача 4 
Да се напише функция, която приема двумерна матрица съдържаща единици и нули, представляваща лабиринт, в който единиците са проходими пространства, а нулите не са. Освен този лабиринт се подават и начална позиция и дестинация. 
1. Да се върне булева стойност дали съществува път от началната позиция до дестинацията.
2. Да се върне дължината на най-късият път.
3. Да се принтира един от най-късите пътища.

Ако предположим, че сигнатурата приема `int maze[][length]`, тогава при следният вход: 
```c++
int lab[][5] = {
			 {1, 1, 0, 1, 1},
			 {0, 1, 1, 1, 0},
			 {0, 1, 0, 1, 1}
	};
```
Най-късият път от `(0, 0)` до `(2, 4)` е с дължина 6 и съответно пътя `(0, 0), (0, 1), (1, 1), (1, 2), (1, 3), (2, 3), (2, 4)`
```c++
int maze[][11] = {
		{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
		{1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1},
		{1, 0, 1, 0, 1, 0, 1, 0 ,1, 0, 1},
		{1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1},
		{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
		{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
	};
```

Най-късият път от `(3, 0)` до `(3, 10)` е с дължина 16 и съответно пътя `(3, 0), (2, 0), (1, 0), (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10), (1, 10), (2, 10), (3, 10)`

Задачата я има в [Hackerrank](https://www.hackerrank.com/contests/noi-ph-finals-practice/challenges/path-in-a-maze/problem), зададена по малко по-различен начин и ограничения.